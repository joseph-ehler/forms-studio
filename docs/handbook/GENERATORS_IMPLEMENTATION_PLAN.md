# Generators Implementation Plan (Week 2)

**Status**: ‚è≥ WAITING FOR PR #1 TO MERGE

**Last updated**: 2025-10-25

---

## Prerequisites

- ‚úÖ PR #1 merged (`feat/ds-flowbite-skin`)
- ‚úÖ Clean main branch
- ‚úÖ All validation passing (`pnpm doctor`)
- ‚úÖ Baseline stable

---

## Phase 1: DS Generator (Day 1-2)

### **Goal**: Prove one generator end-to-end

### **Files to Create**

```
scripts/generators/
  lib/
    generator.config.ts    # Version, allowlist, validation flags
    banner.ts              # @generated header util
    fs.ts                  # Safe file writing + validation
    templates.ts           # Pure template functions
    validation.ts          # Post-gen checks (barrels + doctor)
  
  ds-component.mts         # Main CLI
  
  __tests__/
    ds-component.test.ts   # Snapshot tests
    fixtures/
      (generated after first run)
```

### **Implementation**

**Day 1 Morning**: Create library files
- `generator.config.ts` - Configuration
- `banner.ts` - Banner generation
- `fs.ts` - Safe file operations
- `templates.ts` - Template functions
- `validation.ts` - Post-gen validation

**Day 1 Afternoon**: Create generator
- `ds-component.mts` - Main CLI
- Add script to root `package.json`:
  ```json
  "ds:new": "tsx scripts/generators/ds-component.mts"
  ```

**Day 2 Morning**: Test & validate
- Dry-run: `pnpm ds:new --name=Breadcrumb`
- Review output carefully
- Generate: `pnpm ds:new --name=Breadcrumb --write`
- Run: `pnpm doctor` (must pass)
- Compare to hand-written components

**Day 2 Afternoon**: Snapshot tests
- Create `__tests__/ds-component.test.ts`
- Add fixtures
- Run: `pnpm test:generators`
- Document in handbook

### **Success Criteria**

- ‚úÖ Generated code indistinguishable from hand-written
- ‚úÖ `pnpm doctor` passes
- ‚úÖ Snapshot tests pass
- ‚úÖ Time to generate: <10 minutes
- ‚úÖ Documentation complete

---

## Phase 2: Forms Generator (Day 3-4)

### **Prerequisites**: DS generator proven successful

### **Files to Add**

```
scripts/generators/
  forms-field.mts          # Forms CLI
  __tests__/
    forms-field.test.ts    # Snapshot tests
```

### **Implementation**

**Day 3**: Build forms generator
- Reuse all library functions from DS generator
- Create `forms-field.mts`
- Add script: `"forms:new": "tsx scripts/generators/forms-field.mts"`

**Day 4**: Test & validate
- Dry-run: `pnpm forms:new --name=Text`
- Generate: `pnpm forms:new --name=Text --write`
- Validate with doctor
- Add snapshot tests

### **Success Criteria**

- ‚úÖ Generated fields pass all checks
- ‚úÖ Compose DS primitives correctly
- ‚úÖ Documentation updated

---

## Phase 3: Documentation & Hardening (Day 5)

### **Tasks**

1. **Create handbook entry**
   - `docs/handbook/GENERATORS.md`
   - When to use, when not to
   - Workflow examples
   - Customization strategies

2. **Add CI check (optional)**
   ```yaml
   # .github/workflows/generator-sync.yml
   - name: Check generators in sync
     run: pnpm test:generators
   ```

3. **Update GO/NO-GO checklist**
   - Add generator coverage metric
   - Track time savings

4. **Create escape hatch docs**
   - How to customize generated files
   - When to hand-write instead
   - Pattern: `@generated` vs `@manual` files

---

## Complete Scaffold (Drop-In Ready)

### **1. generator.config.ts**

```typescript
export const GENERATOR_CONFIG = {
  version: '1.0.0',
  allowedPaths: [
    'packages/ds/src/registry/skins',
    'packages/ds/src/components',
    'packages/forms/src/fields',
    'packages/forms/src/registry',
  ],
  banner: {
    include: true,
    style: 'tsdoc', // 'tsdoc' | 'line'
  },
  validation: {
    runBarrels: true,
    runDoctor: true,
  },
} as const;
```

### **2. banner.ts**

```typescript
export function generatedBanner(tool: 'ds:new'|'forms:new', source: string, version: string) {
  const ts = new Date().toISOString();
  return `/**
 * @generated by ${tool} v${version} on ${ts}
 * DO NOT EDIT MANUALLY
 * Regenerate with: pnpm ${tool} --name=<Name> --write
 * Source of truth: ${source}
 */`;
}
```

### **3. fs.ts**

```typescript
import { mkdir, writeFile } from 'node:fs/promises';
import path from 'node:path';
import { GENERATOR_CONFIG } from './generator.config.js';

export type FileOut = { path: string; content: string };

export async function writeAll(files: FileOut[]) {
  for (const f of files) {
    validatePath(f.path);
    await mkdir(path.dirname(f.path), { recursive: true });
    await writeFile(f.path, f.content, 'utf8');
    console.log(`‚úì wrote ${f.path}`);
  }
}

export function list(files: FileOut[]) {
  console.log('üìã Generated files:\n');
  for (const f of files) console.log(`  ‚Ä¢ ${f.path}`);
  console.log('\n(run with --write to apply)');
}

function validatePath(p: string) {
  const ok = GENERATOR_CONFIG.allowedPaths.some(prefix => p.startsWith(prefix));
  if (!ok) throw new Error(`Refusing to write outside allowlist: ${p}`);
}
```

### **4. validation.ts**

```typescript
import { execSync } from 'node:child_process';
import { GENERATOR_CONFIG } from './generator.config.js';

export function validatePostGen() {
  console.log('\nüîç Running validation (barrels + doctor)...');
  if (GENERATOR_CONFIG.validation.runBarrels) execSync('pnpm barrels', { stdio: 'inherit' });
  if (GENERATOR_CONFIG.validation.runDoctor)  execSync('pnpm doctor',  { stdio: 'inherit' });
  console.log('‚úÖ Validation passed');
}
```

### **5. templates.ts** (Core templates)

```typescript
import { generatedBanner } from './banner.js';
import type { FileOut } from './fs.js';

export function kebabize(name: string) {
  return name.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();
}

/** DS SKIN file (registry) */
export function skinTemplate(opts: {
  component: string;
  kebab: string;
  variantType: string;
  skinKeysType: string;
  variants: string[];
  source: string;
  tool: 'ds:new';
  version: string;
}): FileOut {
  const { component, kebab, variantType, skinKeysType, variants, source, tool, version } = opts;
  const banner = generatedBanner(tool, source, version);

  const body = variants.map(v => `  '${v}': {
    '--${kebab}-fg':        'var(--ds-role-${v}-text)',
    '--${kebab}-bg':        'var(--ds-role-${v}-bg)',
    '--${kebab}-hover-bg':  'var(--ds-role-${v}-hover)'
  }`).join(',\n');

  return {
    path: `packages/ds/src/registry/skins/${kebab}.skin.ts`,
    content: `${banner}

import type { SkinRecord } from '../../control/skin-contracts';
import type { ${variantType}, ${skinKeysType} } from '../../control/skin-contracts';

export const ${component.toUpperCase()}_SKIN: SkinRecord<${variantType}, ${skinKeysType}> = {
${body}
};
`
  };
}

/** DS wrapper file (component) */
export function wrapperTemplate(opts: {
  component: string;
  kebab: string;
  tool: 'ds:new';
  version: string;
}): FileOut {
  const { component, kebab, tool, version } = opts;
  const banner = generatedBanner(tool, `packages/ds/src/control/variants.config.ts`, version);

  return {
    path: `packages/ds/src/components/${component}/${component}.tsx`,
    content: `${banner}

import { ${component} as Flowbite${component} } from 'flowbite-react';
import type { CSSProperties } from 'react';
import { ${component.toUpperCase()}_SKIN } from '../../registry/skins/${kebab}.skin';

export interface ${component}Props extends Omit<React.ComponentProps<typeof Flowbite${component}>, 'style'> {
  variant?: keyof typeof ${component.toUpperCase()}_SKIN;
  style?: CSSProperties;
}

export function ${component}(props: ${component}Props) {
  const { variant = Object.keys(${component.toUpperCase()}_SKIN)[0] as any, style, ...rest } = props;
  const skin = ${component.toUpperCase()}_SKIN[variant];
  return <Flowbite${component} data-component="${kebab}" data-variant={variant} style={{ ...skin, ...style }} {...rest} />;
}
`
  };
}

/** DS stories (smoke) */
export function storiesTemplate(opts: { component: string; tool: 'ds:new'; version: string }): FileOut {
  const { component, tool, version } = opts;
  const banner = generatedBanner(tool, `packages/ds/src/control/variants.config.ts`, version);

  return {
    path: `packages/ds/src/components/${component}/${component}.stories.tsx`,
    content: `${banner}

import type { Meta, StoryObj } from '@storybook/react';
import { ${component} } from './${component}';

const meta: Meta<typeof ${component}> = {
  title: 'DS/${component}',
  component: ${component},
};
export default meta;

type Story = StoryObj<typeof ${component}>;

export const Basic: Story = { args: { children: '${component}', variant: 'primary' } };
`
  };
}

/** DS matrix stories (variants) */
export function matrixTemplate(opts: {
  component: string; variants: string[]; tool: 'ds:new'; version: string;
}): FileOut {
  const { component, variants, tool, version } = opts;
  const banner = generatedBanner(tool, `packages/ds/src/control/variants.config.ts`, version);

  const grid = variants.map(v => `<${component} variant="${v}">${component} - ${v}</${component}>`).join('\n        ');

  return {
    path: `packages/ds/src/components/${component}/${component}.matrix.stories.tsx`,
    content: `${banner}

import type { Meta } from '@storybook/react';
import { ${component} } from './${component}';

export default {
  title: 'DS/${component}/Matrix',
  component: ${component},
} as Meta<typeof ${component}>;

export const Variants = () => (
  <div style={{ display: 'grid', gap: 12 }}>
    ${grid}
  </div>
);
`
  };
}

/** DS index barrel inside component folder */
export function indexTemplate(component: string): FileOut {
  return {
    path: `packages/ds/src/components/${component}/index.ts`,
    content: `export * from './${component}';` 
  };
}
```

### **6. ds-component.mts** (Main CLI)

```typescript
#!/usr/bin/env node
import { parseArgs } from 'node:util';
import { kebabize, skinTemplate, wrapperTemplate, storiesTemplate, matrixTemplate, indexTemplate } from './lib/templates.js';
import { writeAll, list } from './lib/fs.js';
import { validatePostGen } from './lib/validation.js';
import { GENERATOR_CONFIG } from './lib/generator.config.js';

async function main() {
  const { values } = parseArgs({
    options: {
      name:  { type: 'string' },
      write: { type: 'boolean', default: false },
    }
  });

  if (!values.name) {
    console.error('Usage: pnpm ds:new --name=<ComponentName> [--write]');
    process.exit(1);
  }

  // Load typed variants from control panel
  const variantsMod = await import('../../packages/ds/src/control/variants.config.ts');
  const component = String(values.name).replace(/[^A-Za-z0-9]/g, '');
  const kebab = kebabize(component);

  const allVariants: string[] = variantsMod.variants?.[component.toLowerCase()] ??
                                variantsMod.variants?.[kebab] ?? ['primary'];

  const files = [
    skinTemplate({
      component,
      kebab,
      variants: allVariants,
      variantType: `${component}Variant`,
      skinKeysType: `${component}SkinKeys`,
      source: 'packages/ds/src/control/variants.config.ts',
      tool: 'ds:new',
      version: GENERATOR_CONFIG.version,
    }),
    wrapperTemplate({ component, kebab, tool: 'ds:new', version: GENERATOR_CONFIG.version }),
    storiesTemplate({ component, tool: 'ds:new', version: GENERATOR_CONFIG.version }),
    matrixTemplate({ component, variants: allVariants, tool: 'ds:new', version: GENERATOR_CONFIG.version }),
    indexTemplate(component),
  ];

  if (!values.write) {
    list(files);
    return;
  }

  await writeAll(files);
  validatePostGen();
}

main().catch(err => { console.error(err); process.exit(1); });
```

### **7. forms-field.mts** (Forms CLI)

```typescript
#!/usr/bin/env node
import { parseArgs } from 'node:util';
import { writeAll, list } from './lib/fs.js';
import { validatePostGen } from './lib/validation.js';
import { GENERATOR_CONFIG } from './lib/generator.config.js';
import { kebabize, generatedBanner } from './lib/templates.js';

function formsTemplates(field: string) {
  const kebab = kebabize(field);
  const banner = (src: string) => generatedBanner('forms:new', src, GENERATOR_CONFIG.version);

  return [
    {
      path: `packages/forms/src/fields/${field}/${field}.tsx`,
      content: `${banner('packages/forms/src/control/field-contracts.ts')}

import { ${field} as DS${field} } from '@intstudio/ds/fb';
import type { FieldProps } from '../../control/field-contracts';

export function ${field}Field(props: FieldProps<'${kebab}'>) {
  const { name, label, error, hint, variant, ...rest } = props;
  return (
    <div data-field="${kebab}">
      {label && <label htmlFor={name}>{label}</label>}
      <DS${field} id={name} variant={variant} {...rest} />
      {hint && <small>{hint}</small>}
      {error && <div role="alert">{String(error)}</div>}
    </div>
  );
}
`
    },
    {
      path: `packages/forms/src/fields/${field}/index.ts`,
      content: `export * from './${field}';` 
    },
    {
      path: `packages/forms/src/fields/${field}/${field}.stories.tsx`,
      content: `${banner('packages/forms/src/control/field-contracts.ts')}
import type { Meta, StoryObj } from '@storybook/react';
import { ${field}Field } from './${field}';

const meta: Meta<typeof ${field}Field> = {
  title: 'Forms/${field}Field',
  component: ${field}Field,
};
export default meta;
type Story = StoryObj<typeof ${field}Field>;
export const Basic: Story = { args: { name: '${kebab}', label: '${field} Field' } };
`
    }
  ];
}

async function main() {
  const { values } = parseArgs({
    options: {
      name:  { type: 'string' },
      write: { type: 'boolean', default: false },
    }
  });

  if (!values.name) {
    console.error('Usage: pnpm forms:new --name=<FieldName> [--write]');
    process.exit(1);
  }

  const field = String(values.name).replace(/[^A-Za-z0-9]/g, '');
  const files = formsTemplates(field);

  if (!values.write) return list(files);

  await writeAll(files);
  validatePostGen();
}

main().catch(err => { console.error(err); process.exit(1); });
```

---

## Testing Strategy

### **Snapshot Tests**

```typescript
// scripts/generators/__tests__/ds-component.test.ts
import { describe, it, expect } from 'vitest';
import { skinTemplate, wrapperTemplate } from '../lib/templates';

describe('ds:new generator', () => {
  it('generates Breadcrumb skin correctly', () => {
    const out = skinTemplate({
      component: 'Breadcrumb',
      kebab: 'breadcrumb',
      variants: ['primary', 'secondary'],
      variantType: 'BreadcrumbVariant',
      skinKeysType: 'BreadcrumbSkinKeys',
      source: 'test',
      tool: 'ds:new',
      version: '1.0.0',
    });
    expect(out.content).toMatchSnapshot();
  });

  it('generates Breadcrumb wrapper correctly', () => {
    const out = wrapperTemplate({
      component: 'Breadcrumb',
      kebab: 'breadcrumb',
      tool: 'ds:new',
      version: '1.0.0',
    });
    expect(out.content).toMatchSnapshot();
  });
});
```

---

## Usage Examples

### **DS Component**

```bash
# Dry-run (review output)
pnpm ds:new --name=Breadcrumb

# Generate (creates files + runs validation)
pnpm ds:new --name=Breadcrumb --write

# Result:
# packages/ds/src/registry/skins/breadcrumb.skin.ts
# packages/ds/src/components/Breadcrumb/Breadcrumb.tsx
# packages/ds/src/components/Breadcrumb/Breadcrumb.stories.tsx
# packages/ds/src/components/Breadcrumb/Breadcrumb.matrix.stories.tsx
# packages/ds/src/components/Breadcrumb/index.ts
```

### **Forms Field**

```bash
# Dry-run
pnpm forms:new --name=Text

# Generate
pnpm forms:new --name=Text --write

# Result:
# packages/forms/src/fields/Text/Text.tsx
# packages/forms/src/fields/Text/Text.stories.tsx
# packages/forms/src/fields/Text/index.ts
```

---

## Success Metrics (Track These)

| Metric | Baseline | Week 2 Target | Month Target |
|--------|----------|---------------|--------------|
| **Time to add DS component** | 30-60 min | <15 min | <10 min |
| **Time to add Forms field** | 45-90 min | <20 min | <15 min |
| **Generator coverage** | 0% | 50% | 90% |
| **Doctor pass rate (post-gen)** | N/A | 100% | 100% |
| **First-pass PR success** | N/A | >80% | >90% |

---

## Rollout Checklist

**Before starting**:
- [ ] PR #1 merged and stable
- [ ] Main branch clean
- [ ] All validation passing

**Phase 1 (DS)**:
- [ ] Create library files
- [ ] Create ds-component.mts
- [ ] Test dry-run
- [ ] Generate Breadcrumb
- [ ] Validate with doctor
- [ ] Add snapshot tests
- [ ] Document workflow

**Phase 2 (Forms)**:
- [ ] Create forms-field.mts
- [ ] Test dry-run
- [ ] Generate TextField
- [ ] Validate with doctor
- [ ] Add snapshot tests

**Phase 3 (Documentation)**:
- [ ] Create GENERATORS.md handbook
- [ ] Update GO/NO-GO with metrics
- [ ] Add escape hatch docs
- [ ] Optional: CI check for sync

---

## Risk Mitigation

### **If Generator Produces Bad Code**
- Dry-run caught it ‚Üí fix template, regenerate
- After write ‚Üí git restore, fix template, rerun
- Snapshot tests prevent regression

### **If Validation Fails**
- Doctor must pass or generation fails
- Templates are pure ‚Üí easy to debug
- Rollback is simple (git restore)

### **If Pattern Needs to Change**
- Update one template
- Regenerate all affected components
- Doctor validates changes

---

## Next Steps After Week 2

1. **Week 3**: Codemods (if generators proven)
2. **Week 3**: Obeya dashboard (reports ‚Üí HTML)
3. **Week 4**: Core Six rollout (boring factory)
4. **Month 2**: Token expansion generator (optional)

---

## üöÄ Bottom Line

**This scaffolding is production-ready and safe.**

Key principles achieved:
- ‚úÖ Dry-run by default
- ‚úÖ Validation gates (doctor + barrels)
- ‚úÖ Typed contracts
- ‚úÖ Pure templates (testable)
- ‚úÖ Allowlist protection

**Wait for PR #1, then implement in sequence.**

The boring, humming, Toyota-grade factory awaits. üè≠
