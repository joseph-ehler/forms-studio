#!/usr/bin/env node
/**
 * DS Component Generator - Toyota Standard Work Pattern
 * 
 * Generates a complete DS component with:
 * - Component file with SKIN pattern
 * - SKIN registry entry
 * - CSS with design tokens
 * - Storybook matrix stories
 * - Type contracts
 * - Barrel exports
 * 
 * Usage:
 *   pnpm ds:new Select
 *   pnpm ds:new Checkbox --variants default,success,danger
 * 
 * Principles:
 * - Jidoka: Built-in quality (all variants validated)
 * - Poka-Yoke: Impossible to skip steps
 * - Standard Work: Every component identical
 * - Kaizen: Templates improve over time
 */

import { writeFile, mkdir, readFile } from 'fs/promises';
import { join } from 'path';
import { parseArgs } from 'util';
import { existsSync } from 'fs';

const ROOT = process.cwd();
const DS_PATH = join(ROOT, 'packages/ds/src');

// Parse args
const { positionals, values } = parseArgs({ 
  allowPositionals: true,
  options: {
    variants: { type: 'string', short: 'v' },
    help: { type: 'boolean', short: 'h' },
  }
});

const componentName = positionals[0];

if (values.help || !componentName) {
  console.log(`
üè≠ DS Component Generator (Toyota Standard Work)

‚ö†Ô∏è  IMPORTANT: Research Flowbite component FIRST!
   Run: pnpm ds:research <ComponentName>

Usage:
  pnpm ds:research <ComponentName>  # Step 1: Research (5 min)
  pnpm ds:new <ComponentName>       # Step 2: Generate (2 min)

Examples:
  pnpm ds:research Checkbox  # Check Flowbite API first
  pnpm ds:new Checkbox       # Then generate wrapper

  pnpm ds:research Select
  pnpm ds:new Select --variants default,success,danger,info

What gets generated:
  ‚úÖ packages/ds/src/fb/<Component>.tsx     - Flowbite wrapper with SKIN
  ‚úÖ packages/ds/src/fb/<Component>.css     - Token-driven styles
  ‚úÖ packages/ds/src/fb/<Component>.stories.tsx - Matrix stories
  ‚úÖ packages/ds/src/registry/skins/<component>.skin.ts - SKIN map
  ‚úÖ packages/ds/src/control/variants.config.ts - Updated variants
  ‚úÖ Barrel exports auto-updated via pnpm barrels

Research-First Workflow (15 min):
  1. Research Flowbite component (5 min) - pnpm ds:research <Name>
  2. Document findings (2 min) - docs/handbook/flowbite-components/
  3. Update generator mapping if needed (1 min) - scripts/ds-new.mjs
  4. Generate component (2 min) - pnpm ds:new <Name>
  5. Validate TypeScript (2 min) - pnpm typecheck
  6. Run pnpm doctor (3 min)
  7. Review in Storybook

See: docs/handbook/FLOWBITE_RESEARCH_PROTOCOL.md
  `);
  process.exit(values.help ? 0 : 1);
}

// Validate component name
if (!/^[A-Z][a-zA-Z0-9]*$/.test(componentName)) {
  console.error('‚ùå Component name must be PascalCase (e.g., Select, Checkbox)');
  process.exit(1);
}

const componentLower = componentName.toLowerCase();
const variantList = values.variants 
  ? values.variants.split(',').map(v => v.trim())
  : ['default', 'success', 'warning', 'danger', 'info'];

console.log('');
console.log('üè≠ Starting DS Component Generation');
console.log(`   Component: ${componentName}`);
console.log(`   Variants: ${variantList.join(', ')}`);
console.log('');

// ============================================
// 1. Generate Component File
// ============================================

const componentPath = join(DS_PATH, 'fb', `${componentName}.tsx`);
if (existsSync(componentPath)) {
  console.error(`‚ùå Component already exists: ${componentPath}`);
  process.exit(1);
}

// Map component names to Flowbite imports
const flowbiteMap = {
  'Badge': 'Badge',
  'Checkbox': 'Checkbox',
  'Radio': 'Radio',
  'Textarea': 'Textarea',
  'Toggle': 'ToggleSwitch',
  'Select': 'Select',
};

const flowbiteName = flowbiteMap[componentName] || componentName;
const usesFlowbite = !!flowbiteMap[componentName];

const componentTemplate = `/**
 * ${componentName} - Production-grade SKIN-driven Flowbite wrapper
 * 
 * Generated by: pnpm ds:new ${componentName}
 * Pattern: Wrap Flowbite component + apply SKIN variables
 * 
 * Features:
 * - ${variantList.length} variants (${variantList.join(', ')})
 * - Wraps Flowbite ${flowbiteName} (battle-tested foundation)
 * - SKIN-driven styling (design tokens only)
 * - A11y: Inherits from Flowbite
 * - Diagnostics: data-* attributes for debugging
 */

import './${componentName}.css';

${usesFlowbite ? `import { ${flowbiteName} as Flowbite${flowbiteName} } from 'flowbite-react';
` : ''}import { ComponentProps } from 'react';
import { twMerge } from 'tailwind-merge';

import { ${componentName}Variant as ${componentName}VariantType } from '../control/variants.config';
import { ${componentName.toUpperCase()}_SKIN } from '../registry/skins/${componentLower}.skin';

// Re-export for backward compatibility
export type { ${componentName}VariantType as ${componentName}Variant };

/**
 * SKIN imported from registry - single source of truth
 * Local component consumes; never defines
 */
const SKIN = ${componentName.toUpperCase()}_SKIN;

export type ${componentName}Props = ${usesFlowbite ? `ComponentProps<typeof Flowbite${flowbiteName}>` : 'React.HTMLAttributes<HTMLDivElement>'} & {
  /**
   * Semantic variant (DS layer)
   * @default '${variantList[0]}'
   */
  variant?: ${componentName}VariantType;
};

/**
 * ${componentName} - Flowbite wrapper with SKIN
 * 
 * Wraps Flowbite's ${flowbiteName} component and applies SKIN variables.
 * All Flowbite props pass through; SKIN adds semantic variants.
 * 
 * @example
 * \`\`\`tsx
 * <${componentName} variant="${variantList[0]}"${componentName === 'Checkbox' || componentName === 'Radio' || componentName === 'Toggle' ? ' checked' : ''}>
 *   ${componentName === 'Select' ? '<option>Option 1</option>' : componentName === 'Checkbox' || componentName === 'Radio' ? 'Label text' : 'Content'}
 * </${componentName}>
 * \`\`\`
 */
export function ${componentName}({
  variant = '${variantList[0]}',
  className,
  style,
  ...rest
}: ${componentName}Props) {
  // Get skin variables for this variant
  const skin = SKIN[variant];
  
  return (
    <${usesFlowbite ? `Flowbite${flowbiteName}` : 'div'}
      data-component="${componentLower}"
      data-variant={variant}
      className={twMerge(className)}
      style={{ ...skin, ...style } as any}
      {...rest as any}
    />
  );
}

// Re-export types (for barrel index.ts)
export type { ${componentName}VariantType as Variant };
`;

// ============================================
// 2. Generate CSS File
// ============================================

const cssPath = join(DS_PATH, 'fb', `${componentName}.css`);
const cssTemplate = `/**
 * ${componentName} styles - Token-driven, automagic
 * 
 * Reads only --${componentLower}-* variables (set by SKIN in ${componentName}.tsx)
 * Never references design tokens/roles directly
 * 
 * Result: Universal styling that adapts to any theme
 */

@layer ds-interactions {
  /* Base styles */
  :where([data-component="${componentLower}"]) {
    color: var(--${componentLower}-fg);
    background: var(--${componentLower}-bg);
    border: 1px solid var(--${componentLower}-border);
    border-radius: var(--ds-radius-control);
    padding-inline: var(--ds-space-3);
    padding-block: var(--ds-space-2);
    font-family: var(--ds-font-sans);
    font-size: var(--ds-text-sm);
    transition: 
      border-color var(--ds-transition-fast),
      background-color var(--ds-transition-fast),
      box-shadow var(--ds-transition-fast);
  }

  /* Hover state */
  :where([data-component="${componentLower}"]:hover:not(:disabled)) {
    border-color: var(--${componentLower}-hover-border, var(--${componentLower}-border));
    background: var(--${componentLower}-hover-bg, var(--${componentLower}-bg));
  }

  /* Focus state */
  :where([data-component="${componentLower}"]:focus-visible) {
    outline: none;
    box-shadow:
      0 0 0 var(--ds-focus-offset) var(--ds-role-bg),
      0 0 0 calc(var(--ds-focus-offset) + var(--ds-focus-ring)) var(--${componentLower}-focus-ring);
  }

  /* Disabled state */
  :where([data-component="${componentLower}"]:disabled) {
    opacity: var(--ds-disabled-opacity, 0.5);
    cursor: not-allowed;
    pointer-events: none;
  }

  /* Invalid state */
  :where([data-component="${componentLower}"][aria-invalid="true"]) {
    border-color: var(--ds-role-danger-hover);
  }
}
`;

// ============================================
// 3. Generate SKIN Registry
// ============================================

const skinPath = join(DS_PATH, 'registry/skins', `${componentLower}.skin.ts`);
const skinTemplate = `/**
 * ${componentName} SKIN Registry
 * 
 * Single source of truth for ${componentLower} variant ‚Üí CSS variable mappings.
 * Consumed by: ${componentName}.tsx, ESLint validation, tests
 * 
 * Pattern: Map semantic roles to local component variables
 * Result: Universal CSS layer reads only --${componentLower}-* vars
 */

import type { ${componentName}SkinKeys, SkinRecord } from '../../control/skin-contracts';
import type { ${componentName}Variant } from '../../control/variants.config';

/**
 * ${componentName} SKIN map:
 *  - Each variant maps semantic roles ‚Üí local --${componentLower}-* variables
 *  - ${componentName}.css only reads --${componentLower}-*; never references tokens/roles directly
 *  - TypeScript enforces completeness (no ESLint rule needed)
 */
export const ${componentName.toUpperCase()}_SKIN: SkinRecord<${componentName}Variant, ${componentName}SkinKeys> = {
${variantList.map(variant => {
  const isDefault = variant === 'default';
  const semanticPrefix = isDefault ? '' : `-${variant}`;
  
  return `  ${variant}: {
    '--${componentLower}-fg': 'var(--ds-role${isDefault ? '-text' : `${semanticPrefix}-text`})',
    '--${componentLower}-bg': 'var(--ds-role${isDefault ? '-surface' : `${semanticPrefix}-bg`})',
    '--${componentLower}-border': 'var(--ds-${isDefault ? 'neutral' : variant}-8)',
    '--${componentLower}-hover-border': 'var(--ds-${isDefault ? 'neutral' : variant}-9)',
    '--${componentLower}-focus-ring': '${isDefault ? 'var(--ds-state-focus-ring)' : `color-mix(in oklab, var(--ds-role${semanticPrefix}-bg) 40%, transparent)`}',
  }`;
}).join(',\n')}
};
`;

// ============================================
// 4. Generate Storybook Stories
// ============================================

const storiesPath = join(DS_PATH, 'fb', `${componentName}.stories.tsx`);
const storiesTemplate = `import type { Meta, StoryObj } from '@storybook/react';
import { ${componentName} } from './${componentName}';

const meta: Meta<typeof ${componentName}> = {
  title: 'DS/Components/${componentName}',
  component: ${componentName},
  tags: ['autodocs'],
  argTypes: {
    variant: {
      control: 'select',
      options: [${variantList.map(v => `'${v}'`).join(', ')}],
    },
  },
};

export default meta;

type Story = StoryObj<typeof ${componentName}>;

/**
 * Matrix Story - Tests all variants in light + dark mode
 * Used by Storybook test runner for visual regression
 */
export const Matrix: Story = {
  render: () => (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
      <div>
        <h3>Light Mode</h3>
        <div style={{ display: 'flex', gap: '1rem', flexWrap: 'wrap' }}>
          ${variantList.map(v => `<${componentName} variant="${v}">${v}</${componentName}>`).join('\n          ')}
        </div>
      </div>
      
      <div data-theme="dark" style={{ padding: '1rem', background: '#1a1a1a' }}>
        <h3 style={{ color: 'white' }}>Dark Mode</h3>
        <div style={{ display: 'flex', gap: '1rem', flexWrap: 'wrap' }}>
          ${variantList.map(v => `<${componentName} variant="${v}">${v}</${componentName}>`).join('\n          ')}
        </div>
      </div>
      
      <div>
        <h3>States</h3>
        <div style={{ display: 'flex', gap: '1rem', flexWrap: 'wrap' }}>
          <${componentName} variant="${variantList[0]}">Default</${componentName}>
          <${componentName} variant="${variantList[0]}" disabled>Disabled</${componentName}>
          <${componentName} variant="${variantList[0]}" aria-invalid="true">Invalid</${componentName}>
        </div>
      </div>
    </div>
  ),
};

export const Basic: Story = {
  args: {
    variant: '${variantList[0]}',
    children: '${componentName} component',
  },
};
`;

// ============================================
// 5. Update variants.config.ts
// ============================================

const variantsConfigPath = join(DS_PATH, 'control/variants.config.ts');
let variantsConfig = await readFile(variantsConfigPath, 'utf-8');

// Check if component already exists
if (variantsConfig.includes(`${componentLower}:`)) {
  console.warn(`‚ö†Ô∏è  ${componentName} variants already exist in variants.config.ts`);
} else {
  // Add new variant entry
  const variantEntry = `  ${componentLower}: [
    ${variantList.map(v => `'${v}'`).join(',\n    ')},
  ] as const,`;
  
  // Insert before closing of variants object
  variantsConfig = variantsConfig.replace(
    /(\s+\/\/ Add more components.*\n)(} as const;)/,
    `$1  ${variantEntry}\n$2`
  );
  
  // Add type export
  const typeExport = `export type ${componentName}Variant = typeof variants.${componentLower}[number];`;
  variantsConfig = variantsConfig.replace(
    /(\/\/ export type SelectVariant.*\n)/,
    `$1${typeExport}\n`
  );
}

// ============================================
// 6. Update skin-contracts.ts
// ============================================

const skinContractsPath = join(DS_PATH, 'control/skin-contracts.ts');
let skinContracts = await readFile(skinContractsPath, 'utf-8');

const skinKeysType = `
/**
 * ${componentName} skin keys
 */
export type ${componentName}SkinKeys =
  | '--${componentLower}-fg'
  | '--${componentLower}-bg'
  | '--${componentLower}-border'
  | '--${componentLower}-hover-border'
  | '--${componentLower}-focus-ring';
`;

if (!skinContracts.includes(`${componentName}SkinKeys`)) {
  // Add before the final export
  skinContracts = skinContracts.replace(
    /(\/\*\*\n \* Generic SKIN record)/,
    `${skinKeysType}\n$1`
  );
}

// ============================================
// Write all files
// ============================================

try {
  await mkdir(join(DS_PATH, 'fb'), { recursive: true });
  await mkdir(join(DS_PATH, 'registry/skins'), { recursive: true });
  
  await writeFile(componentPath, componentTemplate);
  await writeFile(cssPath, cssTemplate);
  await writeFile(skinPath, skinTemplate);
  await writeFile(storiesPath, storiesTemplate);
  await writeFile(variantsConfigPath, variantsConfig);
  await writeFile(skinContractsPath, skinContracts);
  
  console.log('‚úÖ Files generated:');
  console.log(`   üìÑ ${componentPath}`);
  console.log(`   üé® ${cssPath}`);
  console.log(`   üìä ${skinPath}`);
  console.log(`   üìö ${storiesPath}`);
  console.log(`   ‚öôÔ∏è  ${variantsConfigPath} (updated)`);
  console.log(`   ‚öôÔ∏è  ${skinContractsPath} (updated)`);
  console.log('');
  console.log('üè≠ Next steps (Standard Work):');
  console.log('   1. pnpm barrels          # Update barrel exports');
  console.log('   2. pnpm typecheck        # Validate TypeScript');
  console.log('   3. pnpm doctor           # Full validation');
  console.log('   4. pnpm sb               # Review in Storybook');
  console.log('');
  console.log('üìä Expected time: ~10 minutes (including validation)');
  console.log('');
  
} catch (err) {
  console.error(`‚ùå Error generating files: ${err.message}`);
  process.exit(1);
}
