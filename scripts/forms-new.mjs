#!/usr/bin/env node
/**
 * Forms Field Generator - Toyota Standard Work Pattern
 * 
 * Generates a complete Form field with:
 * - Field component (composes DS primitive)
 * - Field config type (in contracts)
 * - Registry entry (auto-wires to FormRenderer)
 * - Storybook stories
 * - Type contracts
 * - Barrel exports
 * 
 * Usage:
 *   pnpm forms:new TextField
 *   pnpm forms:new EmailField --ds-component Input
 *   pnpm forms:new SelectField --ds-component Select
 * 
 * Principles:
 * - Jidoka: Built-in quality (validation wired automatically)
 * - Poka-Yoke: Cannot bypass DS layer
 * - Standard Work: Every field identical pattern
 * - Kaizen: Templates improve over time
 */

import { writeFile, mkdir, readFile } from 'fs/promises';
import { join } from 'path';
import { parseArgs } from 'util';
import { existsSync } from 'fs';

const ROOT = process.cwd();
const FORMS_PATH = join(ROOT, 'packages/forms/src');

// Parse args
const { positionals, values } = parseArgs({ 
  allowPositionals: true,
  options: {
    'ds-component': { type: 'string' },
    help: { type: 'boolean', short: 'h' },
  }
});

const fieldName = positionals[0];

if (values.help || !fieldName) {
  console.log(`
üè≠ Forms Field Generator (Toyota Standard Work)

Usage:
  pnpm forms:new <FieldName> [--ds-component ComponentName]

Examples:
  pnpm forms:new TextField                    # Composes DS Input
  pnpm forms:new EmailField --ds-component Input
  pnpm forms:new SelectField --ds-component Select
  pnpm forms:new CheckboxField --ds-component Checkbox

What gets generated:
  ‚úÖ packages/forms/src/fields/<Field>/<Field>.tsx - Field component
  ‚úÖ packages/forms/src/fields/<Field>/<Field>.stories.tsx - Stories
  ‚úÖ packages/forms/src/control/field-contracts.ts - Updated contracts
  ‚úÖ packages/forms/src/registry/field-types.ts - Updated registry
  ‚úÖ Barrel exports auto-updated via pnpm barrels

Standard Work (15 min):
  1. Generate field files (3 min)
  2. Validate TypeScript (3 min)
  3. Generate stories (3 min)
  4. Run pnpm doctor (6 min)
  5. Review in Storybook
  `);
  process.exit(values.help ? 0 : 1);
}

// Validate field name
if (!/^[A-Z][a-zA-Z0-9]*Field$/.test(fieldName)) {
  console.error('‚ùå Field name must be PascalCase and end with "Field" (e.g., TextField, EmailField)');
  process.exit(1);
}

// Infer DS component from field name
const baseFieldName = fieldName.replace(/Field$/, '');
const dsComponent = values['ds-component'] || baseFieldName;
const fieldType = fieldName.replace(/Field$/, '').replace(/([A-Z])/g, '-$1').toLowerCase().slice(1);

console.log('');
console.log('üè≠ Starting Forms Field Generation');
console.log(`   Field: ${fieldName}`);
console.log(`   DS Component: ${dsComponent}`);
console.log(`   Type: ${fieldType}`);
console.log('');

// ============================================
// 1. Generate Field Component
// ============================================

const fieldPath = join(FORMS_PATH, 'fields', fieldName, `${fieldName}.tsx`);
if (existsSync(fieldPath)) {
  console.error(`‚ùå Field already exists: ${fieldPath}`);
  process.exit(1);
}

const componentTemplate = `/**
 * ${fieldName} - Form field wrapper
 * 
 * Generated by: pnpm forms:new ${fieldName}
 * Pattern: Compose DS primitive + validation
 * 
 * Features:
 * - Composes DS.${dsComponent} (never direct Flowbite)
 * - Schema-driven validation
 * - Auto-wires to FormRenderer
 * - Label + hint + error display
 * - A11y: aria-* attributes
 */

import { forwardRef } from 'react';
import { ${dsComponent} } from '@intstudio/ds/fb';
import { Field } from '@intstudio/ds/fb';

import type { ${fieldName}Config } from '../../control/field-contracts';

export type ${fieldName}Props = ${fieldName}Config & {
  /**
   * Current value
   */
  value?: string;
  
  /**
   * Change handler
   */
  onChange?: (value: string) => void;
  
  /**
   * Validation error message
   */
  error?: string;
};

/**
 * ${fieldName} - Schema-driven, production-unbreakable
 * 
 * Composes:
 * - DS.${dsComponent} (primitive)
 * - DS.Field (label/hint/error wrapper)
 * 
 * How it works:
 * 1. FormRenderer passes config from schema
 * 2. Field handles label/hint/error display
 * 3. DS.${dsComponent} renders input with variants
 * 4. Validation errors wire automatically
 * 
 * @example
 * \`\`\`tsx
 * <${fieldName}
 *   name="email"
 *   label="Email Address"
 *   placeholder="you@example.com"
 *   required
 *   value={email}
 *   onChange={setEmail}
 *   error={errors.email}
 * />
 * \`\`\`
 */
export const ${fieldName} = forwardRef<HTML${dsComponent === 'Input' || dsComponent === 'Textarea' ? 'Input' : dsComponent === 'Select' ? 'Select' : 'Div'}Element, ${fieldName}Props>(
  function ${fieldName}(
    {
      name,
      label,
      hint,
      required = false,
      disabled = false,
      placeholder,
      variant = 'default',
      value,
      onChange,
      error,
      ...rest
    },
    ref
  ) {
    const inputId = \`field-\${name}\`;
    
    return (
      <Field
        id={inputId}
        label={label}
        hint={hint}
        required={required}
        error={error}
      >
        <${dsComponent}
          ref={ref}
          id={inputId}
          name={name}
          placeholder={placeholder}
          disabled={disabled}
          variant={error ? 'danger' : variant}
          value={value}
          onChange={(e) => onChange?.(e.target.value)}
          {...rest}
        />
      </Field>
    );
  }
);
`;

// ============================================
// 2. Generate Storybook Stories
// ============================================

const storiesPath = join(FORMS_PATH, 'fields', fieldName, `${fieldName}.stories.tsx`);
const storiesTemplate = `import type { Meta, StoryObj } from '@storybook/react';
import { useState } from 'react';
import { ${fieldName} } from './${fieldName}';

const meta: Meta<typeof ${fieldName}> = {
  title: 'Forms/Fields/${fieldName}',
  component: ${fieldName},
  tags: ['autodocs'],
};

export default meta;

type Story = StoryObj<typeof ${fieldName}>;

/**
 * Controlled field with state
 */
function ControlledField(props: any) {
  const [value, setValue] = useState('');
  return <${fieldName} {...props} value={value} onChange={setValue} />;
}

export const Basic: Story = {
  render: () => (
    <ControlledField
      name="${fieldType}"
      label="${baseFieldName}"
      placeholder="Enter ${fieldType}..."
    />
  ),
};

export const Required: Story = {
  render: () => (
    <ControlledField
      name="${fieldType}"
      label="${baseFieldName}"
      placeholder="Enter ${fieldType}..."
      required
      hint="This field is required"
    />
  ),
};

export const WithError: Story = {
  render: () => (
    <ControlledField
      name="${fieldType}"
      label="${baseFieldName}"
      placeholder="Enter ${fieldType}..."
      error="This field has an error"
    />
  ),
};

export const Disabled: Story = {
  render: () => (
    <${fieldName}
      name="${fieldType}"
      label="${baseFieldName}"
      placeholder="Enter ${fieldType}..."
      disabled
      value="Disabled value"
    />
  ),
};

/**
 * Matrix Story - All variants + states
 */
export const Matrix: Story = {
  render: () => (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '2rem' }}>
      <div>
        <h3>Variants</h3>
        <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
          <ControlledField
            name="default"
            label="Default"
            placeholder="Default variant"
            variant="default"
          />
          <ControlledField
            name="success"
            label="Success"
            placeholder="Success variant"
            variant="success"
          />
          <ControlledField
            name="warning"
            label="Warning"
            placeholder="Warning variant"
            variant="warning"
          />
          <ControlledField
            name="danger"
            label="Danger"
            placeholder="Danger variant"
            variant="danger"
          />
        </div>
      </div>
      
      <div>
        <h3>States</h3>
        <div style={{ display: 'flex', flexDirection: 'column', gap: '1rem' }}>
          <ControlledField
            name="normal"
            label="Normal"
            placeholder="Normal state"
          />
          <ControlledField
            name="required"
            label="Required"
            placeholder="Required field"
            required
          />
          <ControlledField
            name="with-hint"
            label="With Hint"
            placeholder="Field with hint"
            hint="This is a helpful hint"
          />
          <ControlledField
            name="with-error"
            label="With Error"
            placeholder="Field with error"
            error="This field is invalid"
          />
          <${fieldName}
            name="disabled"
            label="Disabled"
            placeholder="Disabled field"
            disabled
            value="Disabled value"
          />
        </div>
      </div>
    </div>
  ),
};
`;

// ============================================
// 3. Update field-contracts.ts
// ============================================

const contractsPath = join(FORMS_PATH, 'control/field-contracts.ts');
let contractsContent = '';

if (existsSync(contractsPath)) {
  contractsContent = await readFile(contractsPath, 'utf-8');
} else {
  // Create initial contracts file
  contractsContent = `/**
 * Form Field Contracts - TypeScript-based validation
 * 
 * Single source of truth for field configurations.
 * All fields extend BaseFieldConfig for consistency.
 */

/**
 * Base configuration for all form fields
 */
export type BaseFieldConfig = {
  /**
   * Field name (maps to form data key)
   */
  name: string;
  
  /**
   * Display label
   */
  label: string;
  
  /**
   * Optional hint text (shown below label)
   */
  hint?: string;
  
  /**
   * Whether field is required
   */
  required?: boolean;
  
  /**
   * Whether field is disabled
   */
  disabled?: boolean;
  
  /**
   * Placeholder text
   */
  placeholder?: string;
  
  /**
   * Visual variant
   */
  variant?: 'default' | 'success' | 'warning' | 'danger' | 'info';
};

`;
}

// Add field config type
const fieldConfigType = `
/**
 * ${fieldName} configuration
 */
export type ${fieldName}Config = BaseFieldConfig & {
  type: '${fieldType}';
  // Add field-specific config here
  // Example: maxLength?: number;
};
`;

if (!contractsContent.includes(`${fieldName}Config`)) {
  contractsContent += fieldConfigType;
}

// Add to field type union
const fieldTypeUnion = `
/**
 * All field configuration types
 */
export type FieldConfig =
  | ${fieldName}Config;
  // Add more field configs here as they're created
`;

if (!contractsContent.includes('export type FieldConfig')) {
  contractsContent += fieldTypeUnion;
} else if (!contractsContent.includes(`| ${fieldName}Config`)) {
  // Add to existing union
  contractsContent = contractsContent.replace(
    /export type FieldConfig =\n([^;]+);/,
    (match, types) => `export type FieldConfig =\n${types.trimEnd()}\n  | ${fieldName}Config;`
  );
}

// ============================================
// 4. Update field-types.ts (Registry)
// ============================================

const registryPath = join(FORMS_PATH, 'registry/field-types.ts');
let registryContent = '';

if (existsSync(registryPath)) {
  registryContent = await readFile(registryPath, 'utf-8');
} else {
  // Create initial registry file
  registryContent = `/**
 * Field Type Registry
 * 
 * Maps field type strings to React components.
 * Used by FormRenderer to instantiate correct field based on schema.
 */

import type { ComponentType } from 'react';
import type { FieldConfig } from '../control/field-contracts';

/**
 * Field component type
 */
export type FieldComponent<T extends FieldConfig = FieldConfig> = ComponentType<
  T & {
    value?: any;
    onChange?: (value: any) => void;
    error?: string;
  }
>;

/**
 * Field registry - maps type string to component
 */
export const FIELD_REGISTRY: Record<string, FieldComponent> = {};

/**
 * Register a field component
 */
export function registerField<T extends FieldConfig>(
  type: string,
  component: FieldComponent<T>
): void {
  FIELD_REGISTRY[type] = component as FieldComponent;
}

`;
}

// Add import and registration
const importStatement = `import { ${fieldName} } from '../fields/${fieldName}/${fieldName}';`;
const registerStatement = `registerField('${fieldType}', ${fieldName});`;

if (!registryContent.includes(importStatement)) {
  // Add import at the top (after the type imports)
  registryContent = registryContent.replace(
    /(import type.*\n)+/,
    `$&${importStatement}\n`
  );
}

if (!registryContent.includes(registerStatement)) {
  // Add registration at the end
  registryContent += `\n${registerStatement}\n`;
}

// ============================================
// Write all files
// ============================================

try {
  await mkdir(join(FORMS_PATH, 'fields', fieldName), { recursive: true });
  await mkdir(join(FORMS_PATH, 'control'), { recursive: true });
  await mkdir(join(FORMS_PATH, 'registry'), { recursive: true });
  
  await writeFile(fieldPath, componentTemplate);
  await writeFile(storiesPath, storiesTemplate);
  await writeFile(contractsPath, contractsContent);
  await writeFile(registryPath, registryContent);
  
  console.log('‚úÖ Files generated:');
  console.log(`   üìÑ ${fieldPath}`);
  console.log(`   üìö ${storiesPath}`);
  console.log(`   ‚öôÔ∏è  ${contractsPath} (updated)`);
  console.log(`   ‚öôÔ∏è  ${registryPath} (updated)`);
  console.log('');
  console.log('üè≠ Next steps (Standard Work):');
  console.log('   1. pnpm barrels          # Update barrel exports');
  console.log('   2. pnpm typecheck        # Validate TypeScript');
  console.log('   3. pnpm doctor           # Full validation');
  console.log('   4. pnpm sb               # Review in Storybook');
  console.log('');
  console.log('üìä Expected time: ~15 minutes (including validation)');
  console.log('');
  console.log('üí° Tip: The field automatically composes DS.${dsComponent}');
  console.log('   No direct Flowbite imports - DS layer handles all theming.');
  console.log('');
  
} catch (err) {
  console.error(`‚ùå Error generating files: ${err.message}`);
  process.exit(1);
}
